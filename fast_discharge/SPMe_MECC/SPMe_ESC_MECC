# Use the interactive window to run code. need to restart jupyter server? kernal? whenever a change is made to the pybamm module? 
# base (Python 3.9.12)
import sys
import os
import numpy as np
import pandas as pd
import os
from scipy import integrate
import matplotlib.pyplot as plt
sys.path.insert(0, r'c:\Users\Vivian\Dropbox (University of Michigan)\from_box\Research\PyBaMM\PyBaMM')
print(sys.path[0])
import pybamm
print(pybamm.__path__[0])
import inspect


class ExternalCircuitResistanceFunction():
    def __call__(self, variables):
        I = variables["Current [A]"]
        V = variables["Terminal voltage [V]"]
        R_ext = pybamm.FunctionParameter("External resistance [Ohm]",  {"Time [s]": pybamm.t}) 
        R_tab = pybamm.FunctionParameter("Tabbing resistance [Ohm]",  {"Time [s]": pybamm.t})
        return V/I - (R_ext + R_tab)
    
from pybamm import exp, constants, Parameter


def modified_graphite_diffusivity_PeymanMPM(sto, T):
    # D_ref =  Parameter("Negative electrode diffusion coefficient [m2.s-1]")
    D_ref = 8e-14
    E_D_s = 42770/10
    soc = (sto - 0)/(0.8321-0)
    k = 1.12070451*soc + 0.09209274 # Ds_restart_rmseV_11_simultaneous_rest (updated exp C-rate) only exclude kn>9
    return D_ref*k 

def modified_NMC_diffusivity_PeymanMPM(sto, T):
    D_ref =  8e-15
    E_D_s = 18550/10
    soc = (0.837-sto)/(0.837-0.034)
    k =  4.7302281*soc**2  -4.5023245*soc + 1.26466141 # # Ds_restart_rmseV_11_simultaneous_rest (updated exp C-rate)
    return D_ref *k

solutions = []
SOC_0 = 1
SOC_name = SOC_0
Q_nom = 4.6
# h = 0.72753047-0.05 #0.77996386
# Cp = 1.51997699 #1.94584251
R_tab = pybamm.Parameter("Tabbing resistance [Ohm]")
R_ext = pybamm.Parameter("External resistance [Ohm]")
data_sets = []
# R_tab_list =  [0.0085]#, 0.015] # 0.0085 (100%), 0.0078 (75%), 0.007? (50%)

# load data import ESC data from file
raw_data = pd.read_csv("./fast_discharge/SPMe_MECC/ESC_"+  str(int(SOC_name*100)) + "SOC_full.csv")
esc_start = raw_data[-raw_data['Current Shunt']>1].index[0]
esc_end = len(raw_data)
# T_amb = np.mean(raw_data['Cell Temperature'][(raw_data.index < esc_start) & (raw_data['Cell Temperature'] >0)])
data = raw_data[['Time (s)', 'Voltage (V)', 'Cell Temperature', 'Current Shunt', 'Force']].loc[esc_start:esc_end].copy()
data['Current Shunt'] = -data['Current Shunt']
data['Time (s)'] = data['Time (s)'] - data['Time (s)'].loc[esc_start]
df_labels = ['t', 'V', 'Temp','I', 'F']
data.set_axis(df_labels, axis=1, inplace=True)
data['I_C'] = data.I/Q_nom 
AhT_calculated = integrate.cumtrapz(abs(data.I), data.t-data.t.iloc[0])/3600
AhT_calculated = np.append(AhT_calculated,AhT_calculated[-1])
data['SOC'] = SOC_0 - AhT_calculated/Q_nom 
T_amb = data.Temp.iloc[0]
data_sets.append(data)

options = {
    # "thermal": "x-lumped",
#         "side reactions": "decomposition", 
    "operating mode": ExternalCircuitResistanceFunction(),
}
model = pybamm.lithium_ion.SPMe(options = options)
chemistry = pybamm.parameter_sets.Mohtat2020
param = pybamm.ParameterValues(chemistry)

param.update({
    "Tabbing resistance [Ohm]":  0.0086,#0.0041,D
    "External resistance [Ohm]": 0.0067, # 0.0067
    "Cell capacity [A.h]": Q_nom, #nominal
    "Typical current [A]": Q_nom,
    'Nominal cell capacity [A.h]': Q_nom,
    "Negative electrode thickness [m]":62E-06*4.2/5,
    "Positive electrode thickness [m]":67E-06*4.2/5,
    "Lower voltage cut-off [V]": 0,
    "Ambient temperature [K]":T_amb + 273.15,
    "Initial temperature [K]": T_amb + 273.15,
    "Negative tab width [m]":2.5e-2,
    "Positive tab width [m]":2.5e-2,
    "Negative electrode diffusivity [m2.s-1]": 8e-14,
    "Positive electrode diffusivity [m2.s-1]": 8e-15,
}, check_already_exists = False)

V = model.variables["Terminal voltage [V]"]
I = model.variables["Current [A]"]
model.variables.update({
    "Terminal voltage [V]": V - I*R_tab,
    "Actual resistance [Ohm]":V/I,
    }
)

dt = 0.1
t_eval = np.arange(0, 15*60, dt)
solver = pybamm.CasadiSolver(mode="safe", dt_max=1) #, extra_options_setup={"max_num_steps": 10000}
sim = pybamm.Simulation(model, parameter_values = param, solver=solver) 
solution = sim.solve( initial_soc=SOC_0, t_eval = t_eval)
solutions.append(solution)

# Add Dp
param.update({
    "Positive electrode diffusivity [m2.s-1]": modified_NMC_diffusivity_PeymanMPM,
}, check_already_exists = False)
solver = pybamm.CasadiSolver(mode="safe", dt_max=1) #, extra_options_setup={"max_num_steps": 10000}
sim = pybamm.Simulation(model, parameter_values = param, solver=solver) 
solution = sim.solve( initial_soc=SOC_0, t_eval = t_eval)
solutions.append(solution)

# Add Dn
param.update({
    "Negative electrode diffusivity [m2.s-1]": modified_graphite_diffusivity_PeymanMPM,
}, check_already_exists = False)
solver = pybamm.CasadiSolver(mode="safe", dt_max=1) #, extra_options_setup={"max_num_steps": 10000}
sim = pybamm.Simulation(model, parameter_values = param, solver=solver) 
solution = sim.solve( initial_soc=SOC_0, t_eval = t_eval)
solutions.append(solution)

# Plot effect of concentration dependence
labels = ["Constant $D_p$ & $D_n$", "$D_p(c_s)$", "$D_p(c_s)$ & $D_n(c_s)$"]
fig, ax = plt.subplots(6,1, figsize=(4,10), sharex=True)
ax = ax.flatten()
linestyles = [':','--','-.']
sim_colors = ['g','b','r']
# sim_colors = ['tab:blue', 'tab:orange','tab:green']
t_transition = []
# z = len(solutions)-1 # init zorder
# solutions.reverse()
# labels.reverse()
z1 = [4,2,3]
for l, solution in enumerate(solutions):
    z=z1[l]
    # data = data_sets[l]
    t = solution["Time [s]"].entries
    x = solution["x [m]"].entries[:, 0]
    # AhT = solution["Discharge capacity [A.h]"].entries
    x_plot = t
    xlabel = "Time [s]"
    # x_plot = solution["Discharge capacity [A.h]"].entries
    # xlabel = "AhT"
    data_color = 'k' 
    sim_color = sim_colors[l]
    sim_ls = linestyles[l]
    I = solution['C-rate']
    if l ==0:
        ax[0].semilogx(data.t,data.I/param['Nominal cell capacity [A.h]'], label='Data',color = data_color,zorder = 1)
    ax[0].semilogx(x_plot, I(t), linestyle=sim_ls, color = sim_color, label=labels[l],zorder = z)
    ax[0].set_xlabel(xlabel)
    ax[0].set_ylabel('C-rate [A/Ah]')
    # ax[0].legend(loc = "lower left",  prop={'size': 10})
    ax[0].set_ylim([0,51])

    V = solution['Terminal voltage [V]']
    if l ==0:
        ax[1].semilogx(data.t, data.V,color = data_color,zorder = 1)
    ax[1].semilogx(x_plot, V(t),linestyle=sim_ls, color = sim_color,zorder = z)
    ax[1].set_xlabel(xlabel)
    ax[1].set_ylabel('Terminal voltage [V]')
    ax[1].set_ylim([0,2])
    # ax[0,1].legend(bbox_to_anchor=(0.5, 1.2), fancybox=True, ncol=len(SOC_0), prop={'size': 10}) #, 

    c_n_avg = solution['R-averaged negative particle concentration'](t=t, x=x[0])
    soc = (c_n_avg - 0)/(0.8321-0)
    e_soc = (solution['R-averaged negative particle concentration'](t=data.t, x=x[0])- 0)/(0.8321-0) -  data.SOC
    x = solution["x [m]"].entries[:, 0]
    if l ==0:
        ax[2].semilogx(data.t, data.SOC,color = data_color, label = 'Data',zorder = 1)
    ax[2].semilogx(x_plot, soc,linestyle=sim_ls, color = sim_color, label = labels[l],zorder = z)  # can evaluate at arbitrary x (single representative particle)
    ax[2].set_xlabel(xlabel)
    ax[2].set_ylabel('SOC')

    c_e_p= solution['Positive electrolyte concentration [Molar]']
    # x = solution["x [m]"].entries[:, 0]
    ax[3].semilogx(x_plot, c_e_p (t=t, x = x[-1]),color = sim_color,linestyle=sim_ls,zorder = z )  # can evaluate at arbitrary x (single representative particle)
    ax[3].set_xlabel(xlabel)
    ax[3].set_ylabel('$c_{e,p}(x=1)$') # [mol.m-3]
    # ax[3].set_ylabel('$c_{e,p}\big|_{x=1}$') # [mol.m-3]

    # ax[3].set_ylim([0,1])
    # c_e_p_avg= solution['X-averaged positive electrolyte concentration']
    # ax[3].semilogx(x_plot, c_e_p_avg (t=t, x = x[-1]),color = sim_color )  # can evaluate at arbitrary x (single representative particle)
    # ax[3].set_xlabel(xlabel)
    # ax[3].set_ylabel('$c_{e,p,avg}$') # [mol.m-3]
    # # ax[3].set_ylim([0,1])

    # c_e_n = solution['X-averaged negative electrolyte concentration']
    # # x = solution["x [m]"].entries[:, 0]
    # ax[4].semilogx(x_plot, c_e_n (t=t),color = sim_color )  # can evaluate at arbitrary x (single representative particle)
    # ax[4].set_xlabel(xlabel)
    # ax[4].set_ylabel('$c_{e,n}$')

    c_s_p_surf = solution['Positive particle surface concentration']
    x = solution["x [m]"].entries[:, 0]
    ax[4].semilogx(x_plot, c_s_p_surf(t=t, x=x[-1]),color = sim_color,linestyle=sim_ls, zorder = z )  # can evaluate at arbitrary x (single representative particle)
    ax[4].set_xlabel(xlabel)
    ax[4].set_ylabel('$c_{s,surf,p}$')
    # ax[4].set_ylim([0.001,1])
    print(max(c_s_p_surf(t=t, x=x[-1])))
    
    # Dn = solution['X-averaged negative particle effective diffusivity [m2.s-1]'](t=t, x=x[0],r=[0])
    # Dp = solution['Positive particle effective diffusivity [m2.s-1]'](t=t, x=x[-21],r=[0])
    # ax[5].semilogx(x_plot, Dn, linestyle=sim_ls, color = sim_color, label = "$D_n$")  # can evaluate at arbitrary x (single representative particle)
    # ax[5].semilogx(x_plot, Dp, color = sim_color, label = "$D_p$")  # can evaluate at arbitrary x (single representative particle)
    # ax[5].set_ylabel('$D_p$')
    # # ax[5].legend(loc = 'upper left', ncol=3)
    # ax[5].set_ylim([0, 1.5e-14])

    c_s_n_surf = solution['Negative particle surface concentration']
    x = solution["x [m]"].entries[:, 0]
    ax[5].semilogx(x_plot, c_s_n_surf(t=t, x=x[0]),color = sim_color,linestyle=sim_ls, zorder = z )  # can evaluate at arbitrary x (single representative particle)
    ax[5].set_xlabel(xlabel)
    ax[5].set_ylabel('$c_{s,surf,n}$')
    # ax[4].set_ylim([0.001,1])


    # i0 = solution[ 'Negative electrode exchange current density [A.m-2]']
    # x = solution["x [m]"].entries[:, 0]
    # ax[7].plot(x_plot, i0(t=t, x=x[0]),color = sim_color )  # can evaluate at arbitrary x (single representative particle)
    # ax[7].set_xlabel(xlabel)
    # ax[7].set_ylabel('$i_{0,n}$ [A.m-2]')

    # i0 = solution[ 'Positive electrode exchange current density [A.m-2]']
    # x = solution["x [m]"].entries[:, 0]
    # ax[8].plot(x_plot, i0(t=t, x=x[-1]),color = sim_color )  # can evaluate at arbitrary x (single representative particle)
    # ax[8].set_xlabel(xlabel)
    # ax[8].set_ylabel('$i_{0,p}$ [A.m-2]')

    # eta = solution['Negative electrode reaction overpotential [V]']
    # phi = solution['Negative electrolyte potential [V]']
    # x = solution["x [m]"].entries[:, 0]
    # ax[1,3].plot(x_plot, eta(t=t, x=x[0]),color = sim_color )  # can evaluate at arbitrary x (single representative particle)
    # ax[1,3].plot(x_plot, phi(t=t, x=x[0]),color = sim_color, linestyle = ':' )  # can evaluate at arbitrary x (single representative particle)
    # ax[1,3].set_xlabel(xlabel)
    # ax[1,3].set_ylabel('$\eta_n$ [V]')
    # plot transition lines 
    c = 'grey'
    if l  == 2:
        t_transition.append(t[np.where(c_e_p (t=t, x = x[-1]) <=0)[0][0]]) # cep first =0
        # t_transition.append(t[np.where(abs(np.diff(c_s_p_surf(t=t, x = x[-1])))<1e-3)[0][0]]) # csp first =0
        # # t_transition.append(t[np.where(c_s_n_surf(t=t, x = x[0]) < min(c_s_n_surf(t=t, x = x[0])*1.1))[0][0]])
        # # t_transition.append(t[np.where(i0(t=t, x = x[0]) == min(i0(t=t, x = x[0])))[0][0]])
        # t_transition.append(t[np.where(np.diff(c_s_n_surf(t=t, x = x[0]))>-1e-6)][0]) # csn first =0
        t_transition.append(t[np.where(c_s_p_surf (t=t, x = x[-1]) >= 0.90)[0][0]]) # cep first =0
        t_transition.append(t[np.where(c_s_n_surf (t=t, x = x[0]) <=1e-3)[0][0]]) # cep first =0
    
        #for each subplot
        for i, axs in enumerate(fig.get_axes()):
            ylims = axs.get_ylim()
            # make a verical line with annotation at each transition time
            if i>2: 
                t_trans = t_transition[i-3]
                axs.plot([t_trans]*2, list(ylims), color = c, linestyle = ':',label = '_nolegend_')
                if i in [0,1,2,3,5]: # top annotation
                    axs.annotate(str(i-2), xy=(t_trans, np.diff(ylims)*0.87+ ylims[0]), color = c) #
                else: # bottom annotation
                    axs.annotate(str(i-2), xy=(t_trans, np.diff(ylims)*0.07+ ylims[0]), color = c) #
                axs.set_ylim(ylims) # keep original limits

            else:
                ylims = [ylims[0], ylims[1]*1.05] #make more room at the top
                for r, t_trans in enumerate(t_transition):
                    axs.plot([t_trans]*2, list(ylims), color = c, linestyle = ':',  label = '_nolegend_')
                    axs.annotate(str(r+1), xy=(t_trans, np.diff(ylims)*0.89+ ylims[0]), color = c)
                axs.plot([80]*2, list(ylims), color = 'm', linestyle = ':', label = '_nolegend_')
                axs.annotate('Vent', xy=(85, np.diff(ylims)*0.7+ ylims[0]), color = 'm', rotation=-90) #
                axs.set_ylim(ylims) # keep original limits
            # venting line
            # if i ==0:
            # axs.plot([80]*2, list(ylims), color = 'm', linestyle = ':')
            # axs.annotate('Venting', xy=(90, np.diff(ylims)*0.57+ ylims[0]), color = 'm', rotation=-90) #
        # axs.grid()

        z = z-1



print(t_transition)

handles, labels = ax[0].get_legend_handles_labels()
# plt.legend(labels, bbox_to_anchor=(1.02, 0.1), loc='upper center', borderaxespad=0)
ax[0].legend(labels, fancybox=True, ncol=2, bbox_to_anchor=(0.46, 1.62),loc='upper center') 
# fig.legend(handles, labels, loc='upper center', prop={'size': 10}, ncol = 2, bbox_to_anchor=(0.5, 1.05), fancybox=True) #ncol=len(labels)
plt.xlim([t_eval[0],t_eval[-1]])
plt.tight_layout()
plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['ps.fonttype'] = 42
plt.savefig('./fast_discharge/SPMe_MECC/figs/effect_D_c_long.pdf', format='pdf')
plt.show()
